use anyhow::Result;
use executor::Block;
use p3_baby_bear::BabyBear;
use serde::{Deserialize, Serialize};
use sp1_core_executor::SP1ReduceProof;
use sp1_prover::{build::Witnessable, components::SP1ProverComponents};
use sp1_recursion_circuit::machine::SP1CompressWitnessValues;
use sp1_recursion_compiler::config::InnerConfig;
use sp1_sdk::{
    ExecutionReport, HashableKey, Prover, SP1ProofMode, SP1ProofWithPublicValues, SP1Prover,
    SP1ProvingKey, SP1PublicValues, SP1Stdin, SP1VerificationError, SP1VerifyingKey,
};
use sp1_stark::SP1ProverOpts;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZkvProof {
    witness_stream: Vec<Block<BabyBear>>,
}

/// A proof generated by the SP1 RISC-V zkVM bundled together with the public values and the
/// version.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZkvProofWithPublicValues {
    /// The raw proof generated by the SP1 RISC-V zkVM.
    pub proof: ZkvProof,
    /// The public values generated by the SP1 RISC-V zkVM.
    pub public_values: SP1PublicValues,
    /// The version of the SP1 RISC-V zkVM (not necessary but useful for detecting version
    /// mismatches).
    pub sp1_version: String,
    /// The integrity proof generated by the TEE server.
    pub tee_proof: Option<Vec<u8>>,
}

pub trait ZkvProver<C: SP1ProverComponents> {
    /// The inner [`SP1Prover`] struct used by the prover.
    fn inner(&self) -> &SP1Prover<C>;

    /// The version of the current SP1 circuit.
    fn version(&self) -> &str;

    /// Generate the proving and verifying keys for the given program.
    fn setup(&self, elf: &[u8]) -> (SP1ProvingKey, SP1VerifyingKey);

    /// Executes the program on the given input.
    fn execute(&self, elf: &[u8], stdin: &SP1Stdin) -> Result<(SP1PublicValues, ExecutionReport)>;

    /// Proves the given program on the given input in the given proof mode.
    fn prove(&self, pk: &SP1ProvingKey, stdin: &SP1Stdin) -> Result<ZkvProofWithPublicValues>;

    /// Verify that an SP1 proof is valid given its vkey and metadata.
    /// For Plonk proofs, verifies that the public inputs of the `PlonkBn254` proof match
    /// the hash of the VK and the committed public values of the `SP1ProofWithPublicValues`.
    fn verify(
        &self,
        bundle: &ZkvProofWithPublicValues,
        vkey: &SP1VerifyingKey,
    ) -> Result<(), SP1VerificationError>;
}

pub struct ZkvAdapter<T>(pub T);

pub trait ZkvAdapterT<C>
where
    C: SP1ProverComponents,
{
    type BaseProver: Prover<C>;
    fn zkv_adapter(self) -> ZkvAdapter<Self::BaseProver>;
}

impl<T, C> ZkvAdapterT<C> for T
where
    T: Prover<C>,
    C: SP1ProverComponents,
{
    type BaseProver = T;
    fn zkv_adapter(self) -> ZkvAdapter<Self::BaseProver> {
        ZkvAdapter(self)
    }
}

impl<T, C> ZkvProver<C> for ZkvAdapter<T>
where
    T: Prover<C>,
    C: SP1ProverComponents,
{
    fn inner(&self) -> &SP1Prover<C> {
        self.0.inner()
    }

    fn version(&self) -> &str {
        self.0.version()
    }

    fn setup(&self, elf: &[u8]) -> (SP1ProvingKey, SP1VerifyingKey) {
        self.0.setup(elf)
    }

    fn execute(&self, elf: &[u8], stdin: &SP1Stdin) -> Result<(SP1PublicValues, ExecutionReport)> {
        self.0.execute(elf, stdin)
    }

    fn prove(&self, pk: &SP1ProvingKey, stdin: &SP1Stdin) -> Result<ZkvProofWithPublicValues> {
        let SP1ProofWithPublicValues {
            proof,
            public_values,
            sp1_version,
            tee_proof,
        } = self.0.prove(pk, stdin, SP1ProofMode::Compressed)?;
        let SP1ReduceProof { vk, proof } = self.0.inner().shrink(
            *proof.try_as_compressed().unwrap(),
            SP1ProverOpts::default(),
        )?;
        let input = SP1CompressWitnessValues {
            vks_and_proofs: vec![(vk, proof)],
            is_complete: true,
        };
        let input_with_merkle = self.inner().make_merkle_proofs(input);

        let mut witness_stream = Vec::new();
        Witnessable::<InnerConfig>::write(&input_with_merkle, &mut witness_stream);
        let witness_stream: Vec<Block<_>> = witness_stream.iter().map(|a| a.0.into()).collect();

        Ok(ZkvProofWithPublicValues {
            proof: ZkvProof { witness_stream },
            public_values,
            sp1_version,
            tee_proof,
        })
    }

    fn verify(
        &self,
        bundle: &ZkvProofWithPublicValues,
        vkey: &SP1VerifyingKey,
    ) -> Result<(), SP1VerificationError> {
        let witness_stream = bundle.proof.witness_stream.clone();
        let pubs = bundle.public_values.to_vec();
        let vk_hash = vkey.hash_babybear();
        verifier::verify(witness_stream, pubs, vk_hash);
        Ok(())
    }
}
